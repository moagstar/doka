<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Contact Sheet (Tiled Frame)</title>

<style>
  :root{
    --win-left:   2%;
    --win-right:  2%;
    --win-top:    15%;
    --win-bottom: 15%;

    --wax-existing:#E23B2E;
    --wax-empty:#FFFFFF;
    --gap-x: 0rem;
    --gap-y: 0rem;
    --frame-aspect: 1.5;

    /* tweak if you want a small inset or scale on the overlay */
    --hover-inset: 0;          /* e.g. 1px or 1% if you want a margin */
    --hover-scale: 1;          /* e.g. 1.01 for a tiny pop */
    --hover-img-existing: url("hover.png");      /* has photo */
    --hover-img-empty: url("hover-new.png");     /* empty slot */

    /* tweak tile size to taste (px, rem, or %) */
    --bg-tile-size: 512px;   /* keep this in px for easy math */
    --bg-offset-x: 0px;
    --bg-offset-y: 0px;
  }

  html, body{
    height:100%;
    margin:0;
    background:black;
    color:white;
  }
  body {
    background-image: url("background.png");
    background-repeat: repeat;
    background-size: var(--bg-tile-size) auto;
    background-position: var(--bg-offset-x) var(--bg-offset-y);
  }

  .contact-container{
    height:100vh;
    overflow-y:auto;
    scroll-snap-type: y mandatory;
    z-index: 4;
  }

  .contact-sheet{
    min-height:100vh;
    display:grid;
    place-items:center;
    scroll-snap-align:start;
    padding: 2vmin;
    z-index: 4;
  }

  .sheet-grid{
    --cols: 5; --rows: 4;
    display:grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-auto-rows: 1fr;
    gap: var(--gap-y) var(--gap-x);
    width:min(95vw, 1500px);
    z-index: 4;
  }

  /* ====== Frame tile ====== */
  .frame {
    position:relative;
    aspect-ratio: var(--frame-aspect);
    background:#000;              /* base black; overlay draws the artwork */
    width:100%;
    overflow:visible;
  }

  .frame::after {
    content:"";
    position:absolute; inset:0;
    background: center/100% 100% no-repeat url("frame-tile.png");
    z-index: 3;                   /* sits above photo + window */
    pointer-events:none;
  }

  /* Exact 3×2 window placement inside the tile */
  .window{
    position:absolute;
    left:var(--win-left); right:var(--win-right);
    top:var(--win-top); bottom:var(--win-bottom);
    overflow:hidden;               /* critical: clip to window edges */
    z-index: 1;                    /* beneath overlay */
  }

  /* The clickable 3×2 hit area (and where a photo would go) */
  .hit{
    position:absolute; inset:0;    /* fill the window precisely */
    cursor:pointer;
    z-index: 2;                    /* above image if any, below overlay */
  }

  /* (Optional) if you later render real photos into the window */
  .hit > img {
    position:absolute; inset:0;
    width:100%; height:100%;
    object-fit:cover;              /* crop to fill if needed */
    display:block;
    z-index:1;
    filter: grayscale(100%);       /* convert to black and white */
  }

  /* For portrait images that are rotated */
  .hit > img.portrait {
    width: 69%;           /* let width be whatever it needs */
    height: auto;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%) rotate(-90deg);
    transform-origin: center center;
    object-fit: contain;   /* (or just remove object-fit here) */
  }

  /* ====== Wax/grease hover ====== */
  .hit::after{
    content:"";
    position:absolute;
    inset: var(--hover-inset);
    opacity:0;
    transform: scale(var(--hover-scale)) rotate(var(--wax-rot,0deg));
    transition: opacity .14s ease, transform .14s ease;
    pointer-events:none;
    z-index: 5; /* above frame overlay */

    /* draw the PNG; stretch to the window so placement is exact */
    image-rendering:auto;
  }

  /* Use different hover images based on frame state */
  .is-existing .hit::after {
    background: center/101% 101% no-repeat var(--hover-img-existing);
  }

  .is-empty .hit::after {
    background: center/101% 101% no-repeat var(--hover-img-empty);
  }
  .hit:hover::after,
  .hit:focus-visible::after{
    opacity:1;
  }

  /* Dustbin icon for deleting projects */
  .dustbin-icon {
    position: absolute;
    top: 60px;
    right: 20px;
    width: 40px;
    height: 40px;
    background: url("dustbin.svg") no-repeat center/contain;
    filter: invert(21%) sepia(99%) saturate(7414%) hue-rotate(357deg) brightness(94%) contrast(95%); /* Makes it red */
    opacity: 0;
    transition: opacity 0.2s ease;
    cursor: pointer;
    z-index: 10; /* Above everything else */
  }

  .frame:hover .dustbin-icon {
    opacity: 0.35;
  }

  .dustbin-icon:hover {
    opacity: 0.7 !important;
  }
</style>
</head>
<body>

<div class="contact-container">
  <!-- One or more screens; change data-rows/cols to paginate as you like -->
  <section class="contact-sheet">
    <div id="sheetA" class="sheet-grid" data-rows="4" data-cols="5"
         data-existing="0">
    </div>
  </section>
</div>

<script>
  // ====== Build a grid of tiles from a single frame image ======
  const FRAME_SRC = 'frame-tile.png';        // your single-frame PNG/JPG
  const SHEETS = ['sheetA','sheetB'];        // ids of grids to populate

  // Load projects from localStorage
  function loadProjectsFromLocalStorage() {
    try {
      return JSON.parse(localStorage.getItem('darkroomProjects')) || [];
    } catch (error) {
      console.error('Error loading projects from localStorage:', error);
      return [];
    }
  }

  // Navigate to main.html with a project ID
  function openProject(projectId) {
    window.location.href = `main.html?projectId=${projectId}`;
  }

  // Delete a project from localStorage
  function deleteProject(projectId) {
    try {
      // Get the projects list
      let projectsList = loadProjectsFromLocalStorage();

      // Filter out the project to delete
      projectsList = projectsList.filter(project => project.id !== projectId);

      // Save the updated list
      localStorage.setItem('darkroomProjects', JSON.stringify(projectsList));

      // Remove the full project data
      localStorage.removeItem('darkroomProject_' + projectId);

      console.log('Project deleted from localStorage:', projectId);

      // Rebuild the contact sheet
      SHEETS.forEach(buildSheet);
    } catch (error) {
      console.error('Error deleting project from localStorage:', error);
    }
  }

  // Handle file selection for new project
  function handleNewImageSelection(e) {
    const file = e.target.files[0];
    if (!file) return;

    // Compress and store the image
    compressAndStoreImage(file, function(success) {
      if (success) {
        window.location.href = 'main.html?newImage=true';
      } else {
        alert('The image is too large to process. Please try a smaller image.');
      }
    });
  }

  // Compress image before storing in sessionStorage
  function compressAndStoreImage(file, callback) {
    const reader = new FileReader();
    reader.onload = function(event) {
      const img = new Image();
      img.onload = function() {
        // Create canvas for compression
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Calculate new dimensions (max 1200px width/height)
        let width = img.width;
        let height = img.height;
        const maxDimension = 1200;

        if (width > maxDimension || height > maxDimension) {
          if (width > height) {
            height = Math.round(height * (maxDimension / width));
            width = maxDimension;
          } else {
            width = Math.round(width * (maxDimension / height));
            height = maxDimension;
          }
        }

        // Resize image
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);

        // Get compressed data URL (JPEG at 85% quality)
        const compressedDataURL = canvas.toDataURL('image/jpeg', 0.85);

        try {
          // Try to store in sessionStorage
          sessionStorage.setItem('newImageDataURL', compressedDataURL);
          callback(true);
        } catch (error) {
          console.error('Error storing image in sessionStorage:', error);
          callback(false);
        }
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  }

  // Load once to set accurate aspect ratio for tiles
  const tileImg = new Image();
  tileImg.src = FRAME_SRC;
  tileImg.onload = () => {
    const ratio = tileImg.width / tileImg.height || 1.5;
    document.documentElement.style.setProperty('--frame-aspect', ratio);
    SHEETS.forEach(buildSheet);
  };
  tileImg.onerror = () => {
    // Fallback if image fails; still build sheets
    SHEETS.forEach(buildSheet);
  };

  function buildSheet(gridId){
    const grid = document.getElementById(gridId);
    if(!grid) return;

    // Clear the grid first
    grid.innerHTML = '';

    const rows = parseInt(grid.dataset.rows || '4', 10);
    const cols = parseInt(grid.dataset.cols || '5', 10);
    grid.style.setProperty('--rows', rows);
    grid.style.setProperty('--cols', cols);

    // Get projects from localStorage
    const projects = loadProjectsFromLocalStorage();

    // Create frames for existing projects
    for (let i = 0; i < projects.length; i++) {
      const project = projects[i];
      const frame = createFrame(true, i, project);
      grid.appendChild(frame);
    }

    // Calculate how many empty slots to add
    const total = rows * cols;
    const emptySlots = Math.max(0, total - projects.length);

    // Create frames for empty slots
    for (let i = 0; i < emptySlots; i++) {
      const frame = createFrame(false, projects.length + i);
      grid.appendChild(frame);
    }
  }

  function createFrame(isExisting, index, project = null) {
    const frame = document.createElement('div');
    frame.className = 'frame ' + (isExisting ? 'is-existing' : 'is-empty');

    // Slight random rotation for wax outline only
    frame.style.setProperty('--wax-rot', `${(Math.random()*2-1)*0.5}deg`);

    // random tiling
    const x = Math.floor(Math.random() * 100) + 'px';
    document.body.style.setProperty('--bg-offset-x', x);

    // Frame background (tile)
    frame.style.backgroundImage = `url("${FRAME_SRC}")`;

    // Inner window + hit area
    const windowEl = document.createElement('div');
    windowEl.className = 'window';

    const hit = document.createElement('button');
    hit.type = 'button';
    hit.className = 'hit';
    hit.dataset.index = index;

    // If this is an existing project, add the original image
    if (isExisting && project && project.id) {
      // Get the full project data to access the original image
      const fullProject = JSON.parse(localStorage.getItem('darkroomProject_' + project.id));

      if (fullProject && fullProject.imageDataURL) {
        const img = document.createElement('img');
        img.src = fullProject.imageDataURL;
        img.alt = project.name || 'Original image';

        // Check if image is portrait and rotate if needed
        img.onload = function() {
          if (img.naturalHeight > img.naturalWidth) {
            // Portrait image - add portrait class for rotation
            img.classList.add('portrait');
          }
        };

        hit.appendChild(img);
      } else if (project.thumbnailURL) {
        // Fallback to thumbnail if original image not available
        const img = document.createElement('img');
        img.src = project.thumbnailURL;
        img.alt = project.name || 'Processed image';
        hit.appendChild(img);
      }

      // Store project ID for click handler
      hit.dataset.projectId = project.id;

      // Add dustbin icon for deleting the project
      const dustbin = document.createElement('div');
      dustbin.className = 'dustbin-icon';
      dustbin.title = 'Delete project';

      // Add click handler for the dustbin icon
      dustbin.addEventListener('click', (ev) => {
        ev.stopPropagation(); // Prevent triggering the frame click

        // Confirm before deleting
        if (confirm(`Are you sure you want to delete "${project.name}"?`)) {
          deleteProject(project.id);
        }
      });

      frame.appendChild(dustbin);
    }

    // Click handlers
    hit.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (isExisting) {
        // Open existing project
        const projectId = hit.dataset.projectId;
        if (projectId) {
          openProject(projectId);
        }
      } else {
        // Create new project - open file selector
        const fileInput = document.getElementById('new-image-upload');
        fileInput.click();
      }
    });

    windowEl.appendChild(hit);
    frame.appendChild(windowEl);
    return frame;
  }

  // Set up event listener for file input
  document.addEventListener('DOMContentLoaded', function() {
    // Create hidden file input for new images
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = 'new-image-upload';
    fileInput.accept = 'image/*';
    fileInput.style.display = 'none';
    fileInput.addEventListener('change', handleNewImageSelection);
    document.body.appendChild(fileInput);

    // Refresh the contact sheet when the page loads
    SHEETS.forEach(buildSheet);
  });
</script>
</body>
</html>
